import { useState, useEffect, useCallback } from "react";
import { supabase } from "@/integrations/supabase/client";
import { useAuth } from "./useAuth";
import { toast } from "sonner";

export interface GroupMember {
  id: string;
  user_id: string;
  name: string;
}

interface PublicProfile {
  id: string;
  user_id: string;
  name: string;
}

interface GroupInsert {
  name: string;
  is_temporary: boolean;
}

export interface Group {
  id: string;
  name: string;
  is_temporary: boolean;
  created_by: string;
  created_at: string;
  invite_code: string;
  members: GroupMember[];
}

export function useGroups() {
  const { user } = useAuth();
  const [groups, setGroups] = useState<Group[]>([]);
  const [loading, setLoading] = useState(true);

  const fetchGroups = useCallback(async () => {
    if (!user) {
      setGroups([]);
      setLoading(false);
      return;
    }

    try {
      // Fetch groups the user is a member of
      const { data: memberData, error: memberError } = await supabase
        .from("group_members")
        .select("group_id")
        .eq("user_id", user.id);

      if (memberError) throw memberError;

      if (!memberData || memberData.length === 0) {
        setGroups([]);
        setLoading(false);
        return;
      }

      const groupIds = memberData.map((m) => m.group_id);

      // Fetch groups and members in parallel
      const [groupsResult, membersResult] = await Promise.all([
        supabase
          .from("groups")
          .select("*")
          .in("id", groupIds),
        supabase
          .from("group_members")
          .select("group_id, user_id")
          .in("group_id", groupIds)
      ]);

      if (groupsResult.error) throw groupsResult.error;
      if (membersResult.error) throw membersResult.error;

      const groupsData = groupsResult.data;
      const membersData = membersResult.data;

      // Get unique user IDs to fetch profiles
      const userIds = [...new Set(membersData?.map(m => m.user_id) || [])];
      
      // Fetch profiles for all members
      let profilesMap = new Map<string, { id: string; user_id: string; name: string }>();

      if (userIds.length > 0) {
        const { data: profilesData, error: profilesError } = await supabase
          .from("public_profiles")
          .select("id, user_id, name")
          .in("user_id", userIds);

        if (profilesError) {
          console.error("Error fetching member profiles:", profilesError);
          // Continue anyway - members will show with fallback names
        }

        profilesData?.forEach(profile => {
          profilesMap.set(profile.user_id, profile);
        });
      }

      // Build a map of group_id -> members with profiles
      const groupMembersMap = new Map<string, GroupMember[]>();

      membersData?.forEach((member) => {
        const profile = profilesMap.get(member.user_id);

        const groupMember: GroupMember = profile
          ? {
              id: profile.id,
              user_id: profile.user_id,
              name: profile.name,
            }
          : {
              id: member.user_id,
              user_id: member.user_id,
              name: "Okänd användare",
            };

        if (!groupMembersMap.has(member.group_id)) {
          groupMembersMap.set(member.group_id, []);
        }
        groupMembersMap.get(member.group_id)!.push(groupMember);
      });

      // Build groups with members
      const groupsWithMembers: Group[] = (groupsData || []).map((group) => ({
        id: group.id,
        name: group.name,
        is_temporary: group.is_temporary,
        created_by: group.created_by,
        created_at: group.created_at,
        invite_code: group.invite_code,
        members: groupMembersMap.get(group.id) || [],
      }));

      setGroups(groupsWithMembers);
    } catch (error) {
      console.error("Error fetching groups:", error);
      toast.error("Kunde inte hämta grupper");
    } finally {
      setLoading(false);
    }
  }, [user]);

  useEffect(() => {
    fetchGroups();
  }, [fetchGroups]);

  const createGroup = async (name: string, isTemporary: boolean = false, selectedUserIds: string[] = []) => {
    if (!user) {
      toast.error("Du måste vara inloggad");
      return null;
    }

    try {
      // Create the group - member and invite_code are auto-added via database triggers
      // invite_code is generated by a trigger, so we cast to bypass TypeScript requirement
      const { data: groupData, error: groupError } = await supabase
        .from("groups")
        .insert({
          name,
          is_temporary: isTemporary,
        } as { name: string; is_temporary: boolean; invite_code: string })
        .select()
        .single();

      if (groupError) {
        console.error("Group creation error:", groupError.code, groupError.message);
        throw groupError;
      }

      // Add selected users as members
      if (selectedUserIds.length > 0) {
        const membersToAdd = selectedUserIds.map(userId => ({
          group_id: groupData.id,
          user_id: userId,
        }));

        const { error: membersError } = await supabase
          .from("group_members")
          .insert(membersToAdd);

        if (membersError) {
          console.error("Error adding members:", membersError);
          toast.error("Grupp skapad men kunde inte lägga till alla medlemmar");
        }
      }

      await fetchGroups();
      toast.success("Grupp skapad!");
      return groupData;
    } catch (error) {
      console.error("Error creating group:", error);
      const errorMessage = error instanceof Error ? error.message : "Kunde inte skapa grupp";
      toast.error(errorMessage);
      return null;
    }
  };

  const deleteGroup = async (groupId: string) => {
    try {
      const { error } = await supabase
        .from("groups")
        .delete()
        .eq("id", groupId);

      if (error) throw error;

      await fetchGroups();
      toast.success("Grupp borttagen");
    } catch (error) {
      console.error("Error deleting group:", error);
      toast.error("Kunde inte ta bort grupp");
    }
  };

  const addMembers = async (groupId: string, userIds: string[]) => {
    try {
      const membersToAdd = userIds.map(userId => ({
        group_id: groupId,
        user_id: userId,
      }));

      const { error } = await supabase
        .from("group_members")
        .insert(membersToAdd);

      if (error) {
        console.error("Error adding members:", error);
        console.error("Error details:", {
          code: error.code,
          message: error.message,
          details: error.details,
          hint: error.hint,
        });
        throw error;
      }

      await fetchGroups();
      toast.success(`${userIds.length} ${userIds.length === 1 ? 'medlem' : 'medlemmar'} tillagd${userIds.length === 1 ? '' : 'a'}!`);
    } catch (error) {
      console.error("Error adding members:", error);
      const errorMessage = error instanceof Error 
        ? error.message 
        : "Kunde inte lägga till medlemmar";
      toast.error(errorMessage);
    }
  };

  const removeMember = async (groupId: string, userId: string) => {
    try {
      const { error } = await supabase.rpc("remove_group_member", {
        group_id_param: groupId,
        user_id_param: userId,
      }) as { data: boolean | null; error: Error | null };

      if (error) {
        console.error("Error removing member:", error);
        throw error;
      }

      await fetchGroups();
      toast.success("Medlem borttagen");
    } catch (error) {
      console.error("Error removing member:", error);
      const errorMessage = error instanceof Error 
        ? error.message 
        : "Kunde inte ta bort medlem";
      toast.error(errorMessage);
    }
  };

  const regenerateInviteCode = async (groupId: string) => {
    try {
      const { data: newCode, error } = await supabase.rpc("regenerate_invite_code", {
        group_id_param: groupId,
      }) as { data: string | null; error: Error | null };

      if (error) {
        console.error("Error regenerating invite code:", error);
        throw error;
      }

      await fetchGroups();
      toast.success("Ny inbjudningskod genererad");
      return newCode;
    } catch (error) {
      console.error("Error regenerating invite code:", error);
      const errorMessage = error instanceof Error
        ? error.message
        : "Kunde inte generera ny kod";
      toast.error(errorMessage);
      return null;
    }
  };

  const updateGroup = async (groupId: string, name: string) => {
    try {
      const { error } = await supabase
        .from("groups")
        .update({ name })
        .eq("id", groupId);

      if (error) {
        console.error("Error updating group:", error);
        throw error;
      }

      await fetchGroups();
      toast.success("Gruppnamn uppdaterat");
    } catch (error) {
      console.error("Error updating group:", error);
      const errorMessage = error instanceof Error
        ? error.message
        : "Kunde inte uppdatera gruppnamn";
      toast.error(errorMessage);
    }
  };

  return {
    groups,
    loading,
    createGroup,
    deleteGroup,
    addMembers,
    removeMember,
    regenerateInviteCode,
    updateGroup,
    refetch: fetchGroups,
  };
}
